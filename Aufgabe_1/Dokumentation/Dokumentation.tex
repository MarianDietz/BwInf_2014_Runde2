\section{Aufgabe 1 - Buschfeuer}
\subsection{Lösungsidee}

Ein \emphpar{Feld} ist ein quadratisches Stück Land, welches genau einen folgender Zustände inne haben kann:
\begin{itemize}
\item[BRENNBAR] Das Stück Land ist ind der Lage, zu brennen.
\item[BRENNEND] Ein brennendes Stück Land.
\item[GELÖSCHT] Ein Stück Land, welches nie wieder brennen  wird.
\item[LEER] Ein leeres Stück Land.
\end{itemize}

Alle Felder haben die selbe Fläche.

Ein \emphpar{Wald} ist nun die rechteckig-gitterförmige Anordnung von $n\times m$ Feldern. Die \emphpar{Umgebung} $U(f)$ eines Feldes $f$ in einem Wald $W$ ist dabei die Menge an Feldern, welche in $W$ eine gemeinsame Kante mit $f$ haben.

Der Wald wird nun diskret beobachtet. Es ist dabei sichergestellt, dass nur sofern ein Feld bei einer Beobachtung brennend ist, dieses und jedes brennbare Feld seiner Umgebung bei der nächsten Beobachtung brennen werden, sofern diese nicht schon brennen. Diese Eigenschaft des Waldes sei mit \emph{Feuerausbreitung} bezeichnet.

Ab der 2. Beobachtung kann pro Beobachtung genau 1 (brennendes) Feld gelöscht werden. Wird ein brennendes Feld gelöscht, so fängt seine Umgebung bis zur nächsten Beobachtung nicht an zu brennen.\\
Die erste Beobachtung, ab der ein Feld $f$ brennt, heiße \emph{Entflammung} von $f$.


Ziel ist es nun, eine Folge von zu löschenden Feldern anzugeben, sodass bei deren Einhaltung die Anzahl der brennenden Felder minimiert wird.\\


Im Folgenden seinen diejenigen Felder, welche bei mindestens 2 Beobachtungen brennend waren, als \emph{verkohlt} bezeichnet.\\
Nach der Feuerausbreiteung muss jedes Feld der Umgebung eines verkohlten Feldes $c$ brennend sein oder gewesen sein oder seit der Entflammung von $c$ nicht brennbar gewesen sein.

Sei nun zunächst der Fall betrachtet, dass nur brennende Feler gelöscht werden können.

Es ist leicht zu erkennen, dass es die Lösung nicht verschlechtert, wenn ab der 2. Beobachtung bei jeder Beobachtung 1 brennendes Feld gelöscht wird. Daher wird im Folgenden davon ausgegangen, dass bei jeder Beobachtung (ab der 2.) 1 brennendes Feld gelöscht wird. Es gilt nun also für jede dieser Beobachtungen dasjenige brennende Feld zu finden, durch dessen Löschung die Anzahl der im Folgenden (nicht unbedingt umittelbar folgend) zu brennen anfangenden Felder minimiert.

Sei nun eine Beobachtung fixiert.\\
Nun soll für ein brennendes Feld $F$ ein Maß $\mu(F)$ dafür gefunden werden, mit dem bestimmt werden kann, welches Feld zum Löschen in obigem Sinne am Besten ist. Sei $\mu(F)$ daher die Anzahl der brennbaren Felder, zu denen $F$ das brennende Feld mit dem \emph{kleinster Abstand} ist. Dieser kürzeste Abstand ist dabei die minimale Anzahl an Beobachtungen, bis das Feld anfängt zu brennen. (Unter der Annahme, dass keine weiteren Felder gelöscht werden.)\\
Löscht man nun $F$, so wird der kleinste Abstand aller Felder höchstens größer; bei allen Feldern, bei deren kürzestem Abstand $F$ jedoch keine Rolle spielte (bei denen der Abstand zu einem anderen brennenden Feld also kleiner oder gleich dem Abstand zu $F$ ist), tritt keine Veränderung auf.\\
Für 2 Werte $\mu(F_1)$ und $\mu(F_2)$ gilt nun: ist $\mu(F_1) < \mu(F_2)$, so erzeugte $F_2$ bei mehr Feldern eine Vergrößerung des kleinster Abstands als $F_1$.\\
Die \emph{minimale Lebenszeit} eines Feldes sei nun eben der kleinste Abstand zu einem brennenden Feld. Es ist leicht zu erkennen, dass nach mindesten so vielen Beobachtungen, wie die minimale Lebenszeit eines Feldes ist, das Feld zu brennen beginnt.\\
$\mu(F)$ gibt also auch die Anzahl der Felder an, deren minimale Lebenszeit allein durch $F$ besitmmt ist. Löscht man $F$, so wird, wie schon gesehen, die minimale Lebenszeit all dieser Felder höchstens größer, es ist also am Besten, dasjenige Feld $F^\star$ zum Löschen auszuwählen, welches $\mu(\cdot)$ für alle aktuell brennenden Felder maximiert.

Es gilt nun noch $\mu$ effizient zu bestimmen. Da ein Wald eine rechteckige Gitterform besitzt, ist der kürzeste Abstand zwischen 2 Feldern 1, ganau dann, wenn diese Felder eine gemeinsame Kante haben.\\
Fasse man das Gitter nun als Graphen auf, wobei die Felder die Knoten sind und zwischen 2 Knoten eine Kante ist, genau dann, wenn zwischen diesen Feldern eine Kante ist. Es nun offensichtlich, dass dieser Graph ungewichtet und ungerichtet  ist. Somit ist das Finden von kleinsten Abständen mittels einer \emph{Breitensuche} möglich.\\
Dabei sind die Startfelder der Breitensuche die brennenden Felder. Dabei muss für jedes dieser brennenden Felder eine eigene Breitensuche gestartet werden; wobei für alle Breitensuchen gemeinsam die ermittelten kleinsten Abstände gespeichert werden müssen. Zusätzlich zu den kleinsten Abständen müssen auch die dazugehörigen brennenden Felder gespeichert werden, von denen pro Feld eventuell mehr als 1 existiert. Weiterhin muss die Breitensuche nur brennbare Felder besuchen.\\
Sind die kleinsten Abstände gefunden, so kann $\mu$ ermittelt werden, mithilfe simplem durchiterieren über alle Felder und gleichzeitigem Zählen der Felder, für die nur 1 brennendes Feld gespeichert wurde.

In Pseudocode:
{\small
\begin{lstlisting}
Wald	; //Der Wald; ein 2D-Container

AnfangsBrennendeFelder()	{ //Ermittelt die von Anfang brennenden Felder
  brennendeFelder := null; //1D-Container für Positionen brennender Felder
  for (i = 0..Wald.Höhe())
    for (j = 0..Wald.Breite())
       if (Wald[i,j] == BRENNEND)
         brennendeFelder.Add((i;j)); //Gefundene Position hinzufügen
         
  return brennendeFelder; //Alle gefundenen Positionen zurückgeben
}

NächsteBeobachtung(aktBrennendeFelder) { //Ermittelt die bei der nächsten Beonachtung brennenden Felder, aus den Feldern, die aktuell brennen
  neuBrennendeFelder := null;
  for all((x;y) from aktBrennendeFelder)
    if(Wald[x,y] == GELÖSCHT)
      continue; //Feld kann kein Feuer verteilen
      
    Wald[x,y] := VERKOHLT; //2 mal brennende Felder sind verkohlt
    for all((x';y') from Umgebung((x;y)))
      if(Wald[x',y'] == BRENNBAR)
        neuBrennendeFelder.Add((x';y')); //Gefundene Position hinzufügen
        Wald[x',y'] := BRENNEND; //Wald beginnt zu brennen
        
  return neuBrennendeFelder;
}

GetOptBewässerungspunkt(aktBrennendeFelder) { //Ermittelt den besten Bewässerungspunkt
  kleinsterAbstand := null; //Speichert für alle Felder des Waldes den kleinsten Abstand zu jedem Feld aus aktBrennendeFelder
  
  for(i = 0..kleinsterAbstand.Size())
  	Fülle kleinsterAbstand[i] mithilfe einer Breitensuche

  anzEindeutigKleinstAbstände := null;
  
  for (i = 0..Wald.Höhe())
    for (j = 0..Wald.Breite())
      if(Es ex. k mit kleinsterAbstand[k][i,j] eindeutiges Minimum für alle mögliche k)
        anzEindeutigKleinstAbstände[k]++;
  
  return aktBrennendeFelder[k, sodass anzEindeutigKleinstAbstände[k] maximal];
}

SimuliereFeuer() { //Die eigentliche Berechnung
  aktBrennendeFelder := AnfangsBrennendeFelder(); //Anfangs interessante Felder; Kann brennende, von Feuer umschlossene Felder beinhalten
  while(!aktBrennendeFelder.Empty()) //Solange es brennende Felder gibt
    aktBrennendeFelder := NächsteBeobachtung( aktBrennendeFelder) //Ermittle die bei nächster Beobachtung brennenden Felder
    	if(aktBrennendeFelder.Empty())
    	  break;	 //Keine Felder brennen mehr
    	
  Wald[GetOptBewässerungspunkt(aktBrennendeFelder)] := GELÖSCHT; //Lösche das aktuell beste Feld
}
\end{lstlisting}
}

\subsubsection{Korrektheit}
Wie schon beschrieben, wird bei jeder Beobachtung das für diese Beobachtung nach $\mu$ beste Feld zum Löschen ausgewählt.\\
Es gilt also zu zeigen, dass insgesamt nicht weniger Felder abbrennen, sollte bei einer Beobachtung nicht das für diese Beobachtung nach $\mu$ optimalste Feld gelöscht werden. Verallgemeinernd muss gezeigt werden, dass kein $\mu'$ existiert, welches bei midestens 1 Beobachtung 1 anderes Feld als $\mu$ vorschlägt und bei der insgesamt weniger Felder abbrennen als bei $\mu$; dass $\mu$ also \emph{optimal} ist.\\
Außerdem muss gezeigt werden, dass der Algorithmus terminiert. Da der Algorithmus jedoch nur brennende und nicht verkohlte Felder betrachtet und jedes brennendes Feld nach endlicher Zeit ist den Zustand verkohlt übergeht, gibt es einen Zeitpunkt, ab dem alle einst brennenden Felder vekohlt sind. Dann gibt es jedoch keine Felder, auf denen der Algorithmus operieren kann, der Algorithmus terminiert dann, und somit immer.

Nach der Definition von $\mu$ wird dasjenige, beliebige Feld $F_i$ aus allen möglichen Feldern $F_1..F_n$ zum Löschen ausgewählt, welches die minimale Lebenszeit von den meisten Feldern erhöht. Wählte man ein beliebiges Feld $F_i^<$ aus $\{F_1,...,F_n\}$, mit $\mu(F_i^<) < \mu(F_i)$ so erhöht sich nach Definition der minimalen Lebenszeit diese bei $\mu(F_i) - \mu(F_i^<) > 0$ Feldern weniger, als wenn man $F_i$ wählte. Erhalten diese Felder in den nächsten $z_o$ Beobachtungen keine Lebenszeitvelängerung, so brennen sie ab, wobei $z_o$ der kleinste Abstand des Feldes $o$ zu $F_i$ ist.\\
Es verbleibt also zu zeigen, dass es keine Situation geben kann, bei der die Wahl von $F_i^<$ zu einer insgesamt geringeren Anzahl an verbrannten Feldern führt.\\
Angenommen es gäbe solch eine Situation.\\
Dies heißt jedoch, dass es eine oder mehrere Löschungen von Feldern gibt, welche insgesamt dazu führen, dass die Lebenszeit von $\mu(F_i) - \mu(F_i^<) + 1$ Feldern verlängert wird. Außerdem dürfen diese Löschungen nicht möglich sein, wenn $F_i$ anstatt $F_i^<$ gelöscht wird. Dies im Speziellen heißt jedoch, dass Felder gelöscht werden, welche sonst durch die Löschung von $F_i$ eine Lebenszeitverlängerung erhielten. Somit wäre es aber besser gewesen, $F_i$ zu löschen, da bei den Beobachtungen danach auch andere Felder gelöscht werden könnten und die insgesamte Anzahl an verbrannten Feldern so insgesamt gesunken wäre.\footnote{Es ist theoretisch möglich, dass die Wahl zwischen $F_i^<$ und $F_i$ keinen Unterschied macht, beispielsweise, wenn alle Felder innerhalb der nächsten $o$ Beobachtungen verkohlen oder gelöscht werden. Dabei sei $o$ der maximale Abstand, der in $\mu(F_i^<)$ Berücksichtigung fand. Dies stellt jedoch keinen Widerspruch zur Behauptung dar.}
Es ist also optimal, ein Feld mit maximalem $\mu(F_i)$ auszuwählen. Bleibt zu zeigen, dass die Wahl eines speziellen $F_i$ mit maximalem $\mu(F_i)$ an der insgesamten Anzahl an verbrannten Feldern nichts ändert.\\
Sei $F_i^=$ ein beliebiges Feld aus $\{F_1,...,F_n\}$, mit $\mu(F_i^=) = \mu(F_i)$ und $F_i^= \not= F_i$.\footnote{Sei vorrausgestzt, dass ein solches $F_i^=$ existiert. Andernfalls existiert dieser Fall nicht, der Beweis ist dann hier beendet.}\\
Es genügt zu zeigen, dass das Wählen von $\mu(F_i^=)$ keine Verringerung der am Ende insgesamt brennenden Felder gegenüber  $\mu(F_i)$ darstellt, da $\mu(F_i)$ und $\mu(F_i^=)$ beliebig gewählt sind.\\
Angenommen dies sei der Fall.\\


Der Algorithmus ist also korrekt und optimal.

\subsubsection{Laufzeitanalyse}
Eine Breitensuche hat eine Laufzeit von $\mathcal{O}(V + E)$ in einem Graphen mit $E$ Kanten und $V$ Knoten. Speziell hat der Graph bei dieser Aufgabe $n\cdot m$ Knoten und $(n-1)\cdot (m-1)$ Kanten.\\
Eine Breitensuche wird nach obigem Algorithmus bei jeder der insgesamt $b$ Beobachtungen $f(b_i)$-mal benötigt, wobei $f(b_i)$ die Anzahl der zu betrachtenden brennenden Felder bei Beobachtung $b_i$ sei.\\
Eine Breitensuche besucht nach obigem Algorithmus höchstens $n\cdot m - f(b_i)$ Felder; die Breitensuchen haben also eine Laufzeit von $\mathcal{O}(f(b_i)\cdot (2\cdot n\cdot m - f(b_i)))$. Es ist leicht zu erkennen, dass die Funktion $F(x) = x(a-x)$ das Maximum an der Stelle $x_{max} = \frac{a}{2}$ hat. Somit gilt $\mathcal{O}(f(b_i)\cdot (2\cdot n\cdot m - f(b_i))) = \mathcal{O}(\frac{nm}{2}(2nm - \frac{nm}{2}) = \mathcal{O}(\frac{3n²m²}{4}) = \mathcal{O}(n²m²)$
 Es ergibt sich eine Gesamtlaufzeit von $\mathcal{O}(n²\cdot m² \cdot b)$. Mit $b = \mathcal{O}(n\cdot m)$ ergibt sich eine (wohl sehr grobe) obere Schranke der Laufzeit von $\mathcal{O}(n^3 \cdot m^3)$.\\
Mit diesem Algorithmus lassen sich also Lösungen für Wälder gut berechnen, deren Dimensionen 200 nicht überschreiten, bei denen also $\max{n,m} \leq 200$.

\subsection{Umsetzung}
Für die Umsetzung habe ich die Sprache \texttt{C++} verwendet.\\
Zunächst habe ich für ein Feld \texttt{FIELDSTATE} als \texttt{char} definiert.\footnote{Das Wort \enquote{definiert} ist durchaus ernst zu nehmen, da es hier beschreiben soll, dass etwas mittels \texttt{\# define} \enquote{gelöst} wurde.} Dabei kann ein \texttt{FIELDSTATE} einen oder mehrere, ebenfalls definierter, Zustände annehmen. Dabei handelt es sich um die in der Lösungsidee beschriebenen Zustände eines Feldes, \texttt{EMPTY}, \texttt{BURNABLE}, \texttt{BURNED}, \texttt{WATERED} und \texttt{COAL}.\\
Für Wälder habe ich eine Klasse \texttt{Woods} geschrieben. Jeder Wald hat dabei eine Breite (\texttt{Width}) und eine Höhe (\texttt{Height}) und hält sich ein 2-dimensional Variables Feld an \texttt{FIELDSTATE}s \texttt{Fields}.\\
Durch geschickte Operatorenüberladung und geeigntete Akzessormethoden können diese Attribute vollständig gekapselt werden.

Das Lesen der Eingabe übernimmt die Prozedur \texttt{parseInput}, welche die Daten in eine globale Instanz der Klasse \texttt{Woods} \texttt{Forest} einliest.\\
Ist die Eingabe gelesen, werden aus dieser die zu Beginn brennenden Felder mithilfe der Funktion \texttt{getInitialBurningFields} ermittelt und dann gleich an die Prozedur \texttt{simulateFire} weitergereicht. Diese Prozedur \texttt{simulateFire} simuliert nun das Feuer und ermittelt die zu löschenden Felder unter Zuhilfenahme der Funktion \texttt{getOptimalWaterSpot}.\\
Dabei wird nach jedem Löschvorgang eine Ausgabe getätigt, welche die zu löschende Position (oben links mit (0|0) beginnend) ausgibt. Auch wird unter Verwendung von ASCII-Escape-Sequenzen ein Bild in der Konsole angezeigt, welches den Wald darstellt.\\
Ist das Feuer gelöscht (kann es sich also nicht weiter ausbreiten), wird dem NUtzer eine Meldung ausgegeben, wie viele Felder verbrannten und wie viele Felder verbrannt und gelöscht wurden. (Diese beiden Zahlen beschreiben disjunkte Mengen.) Auch hier wird wieder ein Bild erzeugt und ausgegeben.
\newpage
\subsection{Beispiele}
\subsubsection{Beispiel 0}
Die ist das Beispiel aus der Aufgabenstellung. Umgewandelt für mein Programm sieht diese Eingabe folgendermaßen aus\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{0.in}}:
{\small
\lstinputlisting{../Aufgabe_1/0.in}
}
Mein Programm produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{0.out.tex}; Eine Datei \texttt{0.out} mit den ASCII-Escape-Sequenzen exisitert ebenfalls.}\footnote{Um die ASCII-Escape-Sequenzen in \TeX\, korrekt darzustellen, habe ich spezielle Ausgabemethoden geschrieben. Diese produzieren anstatt der ASCII-Sequenzen \TeX -Befehle, welche optisch zu ähnlichen Ergebnissen führen.}:\\
{\ttfamily \small
\input{../Aufgabe_1/0.out.tex}
}
\subsubsection{Beispiel 1}
Eine Situation mit mehr als einem Feuer bei der ersten Beobachtung\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{1.in}}:
{\small
\lstinputlisting{../Aufgabe_1/1.in}
}
Mein Programm produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{1.out.tex}; Eine Datei \texttt{1.out} mit den ASCII-Escape-Sequenzen exisitert ebenfalls.}:\\
{\ttfamily \small
\input{../Aufgabe_1/1.out.tex}
}
\subsubsection{Beispiel 2}
\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{2.in}}:
{\small
\lstinputlisting{../Aufgabe_1/2.in}
}
Mein Programm produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{2.out.tex}; Eine Datei \texttt{2.out} mit den ASCII-Escape-Sequenzen exisitert ebenfalls.}:\\
{\ttfamily \small
\input{../Aufgabe_1/2.out.tex}
}
\subsubsection{Beispiel 3}
Ein (etwas) größeres Beispiel.\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{3.in}}:
{\small
\lstinputlisting{../Aufgabe_1/3.in}
}
Mein Programm produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{3.out.tex2};} Dabei hat die Berechnung wenige Sekunden in Anspruch genommen, sofern nicht die Ausgabe der ASCII-Escape-Sequenzen gefordert wird. Dies erhöhte die Laufzeit auf ca. 30s.:\\
{\ttfamily \small
\input{../Aufgabe_1/3.out.tex2}
}

\subsection{Quelltext}
{\small
\lstinputlisting{../Aufgabe_1/Buschfeuer.cpp}
}