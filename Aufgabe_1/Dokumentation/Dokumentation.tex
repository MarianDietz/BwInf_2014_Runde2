\section{Aufgabe 1 - Buschfeuer}
\subsection{Lösungsidee}

Ein \emphpar{Feld} ist ein quadratisches Stück Land, welches genau einen folgender Zustände inne haben kann:
\begin{itemize}
\item[BRENNBAR] Das Stück Land ist ind der Lage, zu brennen.
\item[BRENNEND] Ein brennendes Stück Land.
\item[GELÖSCHT] Ein Stück Land, welches nie wieder brennen  wird.
\item[LEER] Ein leeres Stück Land.
\end{itemize}

Alle Felder haben die selbe Fläche.

Ein \emphpar{Wald} ist nun die rechteckig-gitterförmige Anordnung von $n\times m$ Feldern. Die \emphpar{Umgebung} $U(f)$ eines Feldes $f$ in einem Wald $W$ ist dabei die Menge an Feldern, welche in $W$ eine gemeinsame Kante mit $f$ haben.

Der Wald wird nun diskret beobachtet. Es ist dabei sichergestellt, dass nur sofern ein Feld bei einer Beobachtung brennend ist, dieses und jedes brennbare Feld seiner Umgebung bei der nächsten Beobachtung brennen werden, sofern diese nicht schon brennen. Diese Eigenschaft des Waldes sei mit \emph{Feuerausbreitung} bezeichnet.

Ab der 2. Beobachtung kann pro Beobachtung genau 1 (brennendes) Feld gelöscht werden. Wird ein brennendes Feld gelöscht, so fängt seine Umgebung bis zur nächsten Beobachtung nicht an zu brennen.\\
Die erste Beobachtung, ab der ein Feld $f$ brennt, heiße \emph{Entflammung} von $f$.


Ziel ist es nun, eine Folge von zu löschenden Feldern anzugeben, sodass bei deren Einhaltung die Anzahl der brennenden Felder minimiert wird.\\


Im Folgenden seinen diejenigen Felder, welche bei mindestens 2 Beobachtungen brennend waren, als \emph{verkohlt} bezeichnet.\\
Nach der Feuerausbreiteung muss jedes Feld der Umgebung eines verkohlten Feldes $c$ brennend sein oder gewesen sein oder seit der Entflammung von $c$ nicht brennbar gewesen sein.

Sei nun zunächst der Fall betrachtet, dass nur brennende Feler gelöscht werden können.

Es ist leicht zu erkennen, dass es die Lösung nicht verschlechtert, wenn ab der 2. Beobachtung bei jeder Beobachtung 1 brennendes Feld gelöscht wird. Daher wird im Folgenden davon ausgegangen, dass bei jeder Beobachtung (ab der 2.) 1 brennendes Feld gelöscht wird. Es gilt nun also für jede dieser Beobachtungen dasjenige brennende Feld zu finden, durch dessen Löschung die Anzahl der im Folgenden (nicht unbedingt umittelbar folgend) zu brennen anfangenden Felder minimiert.

Sei nun eine Beobachtung fixiert.\\
Nun soll für ein brennendes Feld $F$ ein Maß $\mu(F)$ dafür gefunden werden, mit dem bestimmt werden kann, welches Feld zum Löschen in obigem Sinne am Besten ist. Sei $\mu(F)$ daher die Anzahl der brennbaren Felder, zu denen $F$ das brennende Feld mit dem \emph{kleinster Abstand} ist. Dieser kürzeste Abstand ist dabei die minimale Anzahl an Beobachtungen, bis das Feld anfängt zu brennen. (Unter der Annahme, dass keine weiteren Felder gelöscht werden.)\\
Löscht man nun $F$, so wird der kleinste Abstand aller Felder höchstens größer; bei allen Feldern, bei deren kürzestem Abstand $F$ jedoch keine Rolle spielte (bei denen der Abstand zu einem anderen brennenden Feld also kleiner oder gleich dem Abstand zu $F$ ist), tritt keine Veränderung auf.\\
Für 2 Werte $\mu(F_1)$ und $\mu(F_2)$ gilt nun: ist $\mu(F_1) < \mu(F_2)$, so erzeugte $F_2$ bei mehr Feldern eine Vergrößerung des kleinster Abstands als $F_1$.\\
Die \emph{minimale Lebenszeit} eines Feldes sei nun eben der kleinste Abstand zu einem brennenden Feld. Es ist leicht zu erkennen, dass nach mindesten so vielen Beobachtungen, wie die minimale Lebenszeit eines Feldes ist, das Feld zu brennen beginnt.\\
$\mu(F)$ gibt also auch die Anzahl der Felder an, deren minimale Lebenszeit allein durch $F$ besitmmt ist. Löscht man $F$, so wird, wie schon gesehen, die minimale Lebenszeit all dieser Felder höchstens größer, es ist also am Besten, dasjenige Feld $F^\star$ zum Löschen auszuwählen, welches $\mu(\cdot)$ für alle aktuell brennenden Felder maximiert.

Es gilt nun noch $\mu$ effizient zu bestimmen. Da ein Wald eine rechteckige Gitterform besitzt, ist der kürzeste Abstand zwischen 2 Feldern 1, ganau dann, wenn diese Felder eine gemeinsame Kante haben.\\
Fasse man das Gitter nun als Graphen auf, wobei die Felder die Knoten sind und zwischen 2 Knoten eine Kante ist, genau dann, wenn zwischen diesen Feldern eine Kante ist. Es nun offensichtlich, dass dieser Graph ungewichtet und ungerichtet  ist. Somit ist das Finden von kleinsten Abständen mittels einer \emph{Breitensuche} möglich.\\
Dabei sind die Startfelder der Breitensuche die brennenden Felder. Dabei muss für jedes dieser brennenden Felder eine eigene Breitensuche gestartet werden; wobei für alle Breitensuchen gemeinsam die ermittelten kleinsten Abstände gespeichert werden müssen. Zusätzlich zu den kleinsten Abständen müssen auch die dazugehörigen brennenden Felder gespeichert werden, von denen pro Feld eventuell mehr als 1 existiert. Weiterhin muss die Breitensuche nur brennbare Felder besuchen.\\
Sind die kleinsten Abstände gefunden, so kann $\mu$ ermittelt werden, mithilfe simplem durchiterieren über alle Felder und gleichzeitigem Zählen der Felder, für die nur 1 brennendes Feld gespeichert wurde.

In Pseudocode:
{\small
\begin{lstlisting}
Wald	; //Der Wald; ein 2D-Container

AnfangsBrennendeFelder()	{ //Ermittelt die von Anfang brennenden Felder
  brennendeFelder := null; //1D-Container für Positionen brennender Felder
  for (i = 0..Wald.Höhe())
    for (j = 0..Wald.Breite())
       if (Wald[i,j] == BRENNEND)
         brennendeFelder.Add((i;j)); //Gefundene Position hinzufügen
         
  return brennendeFelder; //Alle gefundenen Positionen zurückgeben
}

NächsteBeobachtung(aktBrennendeFelder) { //Ermittelt die bei der nächsten Beonachtung brennenden Felder, aus den Feldern, die aktuell brennen
  neuBrennendeFelder := null;
  for all((x;y) from aktBrennendeFelder)
    if(Wald[x,y] == GELÖSCHT)
      continue; //Feld kann kein Feuer verteilen
      
    Wald[x,y] := VERKOHLT; //2 mal brennende Felder sind verkohlt
    for all((x';y') from Umgebung((x;y)))
      if(Wald[x',y'] == BRENNBAR)
        neuBrennendeFelder.Add((x';y')); //Gefundene Position hinzufügen
        Wald[x',y'] := BRENNEND; //Wald beginnt zu brennen
        
  return neuBrennendeFelder;
}

GetOptBewässerungspunkt(aktBrennendeFelder) { //Ermittelt den besten Bewässerungspunkt
  kleinsterAbstand := null; //Speichert für alle Felder des Waldes den kleinsten Abstand zu jedem Feld aus aktBrennendeFelder
  
  for(i = 0..kleinsterAbstand.Size())
  	Fülle kleinsterAbstand[i] mithilfe einer Breitensuche

  anzEindeutigKleinstAbstände := null;
  
  for (i = 0..Wald.Höhe())
    for (j = 0..Wald.Breite())
      if(Es ex. k mit kleinsterAbstand[k][i,j] eindeutiges Minimum für alle mögliche k)
        anzEindeutigKleinstAbstände[k]++;
  
  return aktBrennendeFelder[k, sodass anzEindeutigKleinstAbstände[k] maximal];
}

SimuliereFeuer() { //Die eigentliche Berechnung
  aktBrennendeFelder := AnfangsBrennendeFelder(); //Anfangs interessante Felder; Kann brennende, von Feuer umschlossene Felder beinhalten
  while(!aktBrennendeFelder.Empty()) //Solange es brennende Felder gibt
    aktBrennendeFelder := NächsteBeobachtung( aktBrennendeFelder) //Ermittle die bei nächster Beobachtung brennenden Felder
    	if(aktBrennendeFelder.Empty())
    	  break;	 //Keine Felder brennen mehr
    	
  Wald[GetOptBewässerungspunkt(aktBrennendeFelder)] := GELÖSCHT; //Lösche das aktuell beste Feld
}
\end{lstlisting}
}

\subsubsection{Korrektheit}
Wie schon beschrieben, wird bei jeder Beobachtung das für diese Beobachtung nach $\mu$ beste Feld zum Löschen ausgewählt.\\
Es gilt also zu zeigen, dass insgesamt nicht weniger Felder abbrennen, sollte bei einer Beobachtung nicht das für diese Beobachtung nach $\mu$ optimalste Feld gelöscht werden. 

Es lässt sich jedoch ein einfaches Beispiel konstruieren, indem eben dies der Fall ist; eine bessere Lösung also gefunden werden kann, wird nicht das nach $\mu$ optimalste Feld gelöscht:

\begin{multicols}{2}
Die Löschung nach dem Algorithmus:
{\ttfamily \small
\input{../Aufgabe_1/x.out.tex}
}

Eine bessere Löschung:
{\ttfamily \small
\input{../Aufgabe_1/x-opt.out.tex}
}
\end{multicols}

Der Algorithmus ist also nicht optimal, es handelt sich um eine Heuristik. Dabei liefert sie bei vielen Eingaben \emph{ziemlich} gute Ergebnisse\footnote{Siehe dazu Sektion Beispiele}. Zum Vergleich habe ich den Brute-Force-Ansatz implementiert, der garantiert optimale Löschungen liefert. 

\subsubsection{Laufzeitanalyse}
Der Brute-Force-Ansatz probiert alle Möglichkeiten an verschiedenen Löschungen und wählt die optimalste. Grob überschlagen gibt es für jede Löschung 4 Möglichkeiten, somit ergibt sich eine grobe obere Schranke für den Worst-Case von $\mathcal{O}(4^b)$, mit $b$ der Anzahl der Löschungen der Lösung\footnote{Es gibt wohl Pfade im Suchbaum, die länger als $b$ sind; durch geschicktes Pruning ist diese Schranke jedoch einhaltbar}. Dieser Ansatz hat also eine exponenzielle Laufzeit, im Gegensatz zu der Heuristik wie im Folgenden gezeigt wird.

Eine Breitensuche hat eine Laufzeit von $\mathcal{O}(V + E)$ in einem Graphen mit $E$ Kanten und $V$ Knoten. Speziell hat der Graph bei dieser Aufgabe $n\cdot m$ Knoten und $(n-1)\cdot (m-1)$ Kanten.\\
Eine Breitensuche wird nach obigem Algorithmus bei jeder der insgesamt $b$ Beobachtungen $f(b_i)$-mal benötigt, wobei $f(b_i)$ die Anzahl der zu betrachtenden brennenden Felder bei Beobachtung $b_i$ sei.\\
Eine Breitensuche besucht nach obigem Algorithmus höchstens $n\cdot m - f(b_i)$ Felder; die Breitensuchen haben also eine Laufzeit von $\mathcal{O}(f(b_i)\cdot (2\cdot n\cdot m - f(b_i)))$. Es ist leicht zu erkennen, dass die Funktion $F(x) = x(a-x)$ das Maximum an der Stelle $x_{max} = \frac{a}{2}$ hat. Somit gilt $\mathcal{O}(f(b_i)\cdot (2\cdot n\cdot m - f(b_i))) = \mathcal{O}(\frac{nm}{2}(2nm - \frac{nm}{2}) = \mathcal{O}(\frac{3n²m²}{4}) = \mathcal{O}(n²m²)$
 Es ergibt sich eine Gesamtlaufzeit von $\mathcal{O}(n²\cdot m² \cdot b)$. Mit $b = \mathcal{O}(n\cdot m)$ ergibt sich eine (wohl sehr grobe) obere Schranke der Laufzeit von $\mathcal{O}(n^3 \cdot m^3)$.\\
Mit diesem Algorithmus lassen sich also Lösungen für Wälder gut berechnen, deren Dimensionen 200 nicht überschreiten, bei denen also $\max{n,m} \leq 200$.

\subsubsection{Eine andere Lösungsidee}

Aus jeder Beobachtung kann nur eine bestimmte Anzahl an anderen Beobachtungen entstehen. Dabei gibt es eine \emph{Startbeobachtung}, nämlich die erste Beobachtung überhaupt. Auch gibt es letzte Beobachtungen, nach denen sich das Feuer nicht mehr ändert. \\
Es entsteht ein \emph{Zustandsgraph} $Z = (B,E)$, welcher die Beobachtungen als Knoten hat und bei dem zwischen 2 Knoten eine Kante ist, genau dann, wenn es möglich ist von einer Beobachtung zu einer anderen gelangen kann; da sich das Feuer immer weiter ausbreitet ist der Graph also ein gerichteter, azyklischer Graph.

Ist der kürzeste Pfad von einer letzten Beobachtung zur Startbeobachtung kürzer, als der kürzeste Pfad von einer anderen letzten Beobachtung zur Startbeobachtung, so ist auch die Gesamtanzahl der brennenden Felder der ersten Lösung geringer als die der zweiten. Nur unter den Lösungen, die gleich weit von der Startbeobachtung entfernt sind muss die Güte explizit verglichen werden.

Daraus lässt sich direkt ein Algorithmus ableiten. Von der Startbeobachtung wird eine BFS auf dem Zustandsgraphen gestartet. Dabei wird anstatt der Queue eine Priority Queue verwendet, welche die Elemente zuerst nach Entfernung von der Startbeobachtung und dann nach der Anzahl der brennenden Felder sortiert. Diese Verwendung der Breitensuche wird oft auch \emph{State-Space-Search} genannt.

Wird das Problem auf diese Weise gelöst, so lässt sich auch überprüfen, ob es besser sein kann, nicht brennende Felder zu löschen. Dazu wird zusätzlich zu jeder Beobachtung noch eine weitere Zahl gespeichert. Diese Zahl gibt die Anzahl der Beobachtungen an, bei welchen keine Löschung durchgeführt wurde. Ist bei einer Beobachtung diese Zahl nun größer oder gleich als die verbleibende Anzahl an brennenden Feldern, so kann das gesamte Feuer gelöscht werden. Die Löschungen werden sozusagen "nach hinten verschoben". In der Realität würde dann keine Löschung ausgelassen sondern ein nicht brennendes Feld gelöscht werden.

Mit dieser Änderung wird der Zustandsgraph etwas größer, der eigentliche Algorithmus funktioniert jedoch weiterhin.

\subsubsection{Korrektheit}

Im Folgenden wird davon ausgegangen, dass bei jeder Beobachtung ein Feld gelöscht wird.

Es genügt zu zeigen, dass es keine zwei Lösungen geben kann derart, dass die eine Lösung das Feuer nach $k_1$ Löschungen und die andere nach $k_2 > k_1$ Löschungen komplett löscht, und dass die Anzahl der insgesamt verbrannten Felder bei der 2. Lösung geringer ist als bei der ersten. 

Angenommen $L_1$ und $L_2$ seien 2 Löschungen dieser Art, d.h. für die Anzahl der insgesamt verbrannten Felder $A$ gilt $A(L_1) > A(L_2)$ und bei $L_2$ wuden insgesamt mehr Felder gelöscht.

\subsubsection{Laufzeitanalyse}

Die Berechnung der Nachbarknoten einer Beobachtung im Zustandsgraphen benötigt schlimmstenfalls $\mathcal{O}(nm)$. Die State-Space-Search besucht wie eine normale Breitensuche schlimmstenfalls jeden Knoten im Zustandsgraphen 1 mal, bricht jedoch nach der ersten gefundenen Lösung ab. Somit werden maximal $\mathcal{O}((nm)^k)$ Berechnungen durchgeführt, wenn $k$ die  Anzahl der Löschungen in der Lösung ist.
Somit ist dieser Algorithmus im Worst-Case-Szenario nicht besser als ein Brute-Force-Algorithmus; allerdings wird die Lösungssuche in der Regel stark geprunt.

Auch benötigt dieser Algorithmus schlimmsten exponentiell viel Speicherplatz.

\subsection{Umsetzung}
Für die Umsetzung habe ich die Sprache \texttt{C++} verwendet. Dabei habe ich sowohl den Brute-Force-Ansatz als auch die Heuristik implementiert.\\
Zunächst habe ich mir für Wälder eine Klasse \texttt{Woods} geschrieben. Deren Deklaration findet sich in der Datei \texttt{Woods.h}, die Implementierung in der Datei \texttt{Woods.cpp}. Jeder Wald hat dabei eine Breite (\texttt{Width}) und eine Höhe (\texttt{Height}).

Dabei benutzen Wälder für die Representierung eines Feldes einen \texttt{FIELDSTATE}, welcher als \texttt{char} definiert ist. \footnote{Das Wort \enquote{definiert} ist durchaus ernst zu nehmen, da es hier beschreiben soll, dass etwas mittels \texttt{\# define} \enquote{gelöst} wurde.} Dabei kann ein \texttt{FIELDSTATE} einen oder mehrere, ebenfalls definierter, Zustände annehmen. Dabei handelt es sich um die in der Lösungsidee beschriebenen Zustände eines Feldes, \texttt{EMPTY}, \texttt{BURNABLE}, \texttt{BURNED}, \texttt{WATERED} und \texttt{COAL}.\\

Ein Wald hält sich nun ein 2-dimensional, variabel großes Feld von FIELDSTATEs, der eigentliche Wald.\\
Durch geschickte Operatorenüberladung und geeigntete Akzessormethoden können diese Attribute vollständig gekapselt werden.

Der eigentliche Algorithmus findet sich in der Datei \texttt{Buschfeuer.cpp}; die Ein- und Ausgabe steht in der Datei \texttt{Buschfeuer.h}\\
Das Lesen der Eingabe übernimmt die Prozedur \texttt{parseInput}, welche die Daten in eine globale Instanz der Klasse \texttt{Woods} \texttt{Forest} einliest.\\
Ist die Eingabe gelesen, werden aus dieser die zu Beginn brennenden Felder mithilfe der Funktion \texttt{getInitialBurningFields} ermittelt und dann gleich an die Prozedur \texttt{simulateFire} weitergereicht. Diese Prozedur \texttt{simulateFire} simuliert nun das Feuer und ermittelt die zu löschenden Felder unter Zuhilfenahme der Funktion \texttt{getOptimalWaterSpot}.\\
Dabei wird nach jedem Löschvorgang eine Ausgabe getätigt, welche die zu löschende Position (oben links mit (0|0) beginnend) ausgibt. Auch wird unter Verwendung von ASCII-Escape-Sequenzen ein Bild in der Konsole angezeigt, welches den Wald darstellt.\\
Ist das Feuer gelöscht (kann es sich also nicht weiter ausbreiten), wird dem NUtzer eine Meldung ausgegeben, wie viele Felder verbrannten und wie viele Felder verbrannt und gelöscht wurden. (Diese beiden Zahlen beschreiben disjunkte Mengen.) Auch hier wird wieder ein Bild erzeugt und ausgegeben.


Die Implementierung der State-Space-Search kann in der Datei \texttt{Buschfeuer.cpp} nachgelesen werden, dabei wird der Zustandsgraph nicht komplett vorberechnet, sonder erst just-in-time berechnet. Die Ein- und Ausgabe ist dabei die selbe wie bei dem anderen Algorithmus.

\subsubsection{Eingabeformat}
Wird mein Programm über ein Terminal gestartet, so können ihm bis zu 2 Kommandozeilenparameter übergeben werden:
\begin{itemize}
\item[Arg. 1] Pfad zu einer Daei mit einer Eingabe
\item[Arg. 2] Pfad zu einer Datei für eine Ausgabe; existierende Dateien werden überschrieben.\\
Dabei gibt die Dateiendung dieser Datei das Verhalten meines Programmes an:
\end{itemize}
\newpage
\subsection{Beispiele}
\subsubsection{Beispiel 0}
Die ist das Beispiel aus der Aufgabenstellung. Umgewandelt für mein Programm sieht diese Eingabe folgendermaßen aus\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{0.in}}:
{\small
\lstinputlisting{../Aufgabe_1/0.in}
}
Die Heuristik produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{0.out.tex}; Eine Datei \texttt{0.out} mit den ASCII-Escape-Sequenzen exisitert ebenfalls.}\footnote{Um die ASCII-Escape-Sequenzen in \TeX\, korrekt darzustellen, habe ich spezielle Ausgabemethoden geschrieben. Diese produzieren anstatt der ASCII-Sequenzen \TeX -Befehle, welche optisch zu ähnlichen Ergebnissen führen.}:\\
{\ttfamily \small
\input{../Aufgabe_1/0.out.tex}
}

Diese Ausgabe deckt sich auch mit der der State-Space-Search, weshalb ich deren Ausgabe hier weglasse.

\subsubsection{Beispiel 1}
Eine Situation mit mehr als einem Feuer bei der ersten Beobachtung\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{1.in}}:
{\small
\lstinputlisting{../Aufgabe_1/1.in}
}
Die Heuristik produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{1.out.tex}; Eine Datei \texttt{1.out} mit den ASCII-Escape-Sequenzen exisitert ebenfalls.}:\\
{\ttfamily \small
\input{../Aufgabe_1/1.out.tex}
}
\subsubsection{Beispiel 2}
\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{2.in}}:
{\small
\lstinputlisting{../Aufgabe_1/2.in}
}
Mein Programm produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{2.out.tex}; Eine Datei \texttt{2.out} mit den ASCII-Escape-Sequenzen exisitert ebenfalls.}:\\
{\ttfamily \small
\input{../Aufgabe_1/2.out.tex}
}
\subsubsection{Beispiel 3}
Ein (etwas) größeres Beispiel.\footnote{Diese Eingabe finden Sie auch in der Datei \texttt{3.in}}:
{\small
\lstinputlisting{../Aufgabe_1/3.in}
}
Mein Programm produziert folgende Ausgabe\footnote{Diese Ausgabe finden Sie auch in der Datei \texttt{3.out.tex2};} Dabei hat die Berechnung wenige Sekunden in Anspruch genommen, sofern nicht die Ausgabe der ASCII-Escape-Sequenzen gefordert wird. Dies erhöhte die Laufzeit auf ca. 30s.:\\
{\ttfamily \small
\input{../Aufgabe_1/3.out.tex2}
}

\subsection{Quelltext}
\paragraph{Woods.h} \mbox{}

{\small
\lstinputlisting{../Aufgabe_1/Woods.h}
}

\paragraph{Woods.cpp}\mbox{}

{\small
\lstinputlisting{../Aufgabe_1/Woods.cpp}
}

\paragraph{Buschfeuer.h} Dies ist die Ein- und Ausgabe; sowie einige Definitionen.

{\small
\lstinputlisting{../Aufgabe_1/Buschfeuer.h}
}

\paragraph{Buschfeuer.cpp} Dies ist die Implementierung der Heuristik.

{\small
\lstinputlisting{../Aufgabe_1/Buschfeuer.cpp}
}

\paragraph{Buschfeuer2.cpp} Dies ist die Implementierung des Brute-Force-Ansatzes.

{\small
\lstinputlisting{../Aufgabe_1/Buschfeuer2.cpp}
}
